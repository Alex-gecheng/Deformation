# ARAP 网格变形算法实验报告

## 1. 实验目的

本实验旨在实现并验证 **ARAP (As-Rigid-As-Possible)** 网格变形算法。ARAP 是一种基于局部刚性的网格变形方法，能够在保持网格局部形状特征的同时，实现平滑自然的变形效果。通过本实验，我们期望：

1. 理解 ARAP 算法的基本原理和数学推导
2. 实现完整的 ARAP 变形算法
3. 验证算法在平面网格上的变形效果
4. 分析算法的收敛性和变形质量

## 2. 算法原理

### 2.1 ARAP 算法概述

ARAP 算法的核心思想是：在网格变形过程中，尽量保持每个顶点邻域的局部刚性，即尽可能保持局部区域的形状不变，只允许旋转和平移，而不允许缩放和剪切。

### 2.2 数学建模

对于网格中的每个顶点 $i$，ARAP 算法最小化以下能量函数：

$$E = \sum_i \sum_{j \in N(i)} w_{ij} \| (p_i' - p_j') - R_i(p_i - p_j) \|^2$$

其中：
- $p_i, p_j$ 是原始网格中的顶点坐标
- $p_i', p_j'$ 是变形后的顶点坐标
- $R_i$ 是顶点 $i$ 的局部旋转矩阵
- $N(i)$ 是顶点 $i$ 的邻域顶点集合
- $w_{ij}$ 是权重（本实现中使用均一权重）

### 2.3 迭代优化

ARAP 算法采用交替优化的策略，每次迭代包含两个步骤：

#### 2.3.1 Local Step（局部步骤）

对于每个顶点 $i$，计算最优的局部旋转矩阵 $R_i$：

1. 计算局部协方差矩阵：
   $$S_i = \sum_{j \in N(i)} (p_j - p_i)(p_j' - p_i')^T$$

2. 对 $S_i$ 进行 SVD 分解：$S_i = U \Sigma V^T$

3. 计算旋转矩阵：$R_i = V U^T$（确保行列式为正值）

#### 2.3.2 Global Step（全局步骤）

固定旋转矩阵 $R_i$，求解变形后的顶点位置 $p_i'$：

1. 构建拉普拉斯矩阵 $L$（基于邻接关系）

2. 构建右端项：
   $$b_i = \sum_{j \in N(i)} \frac{1}{2}(R_i + R_j)(p_i - p_j)$$

3. 求解线性系统：$L \cdot p' = b$

4. 应用硬约束（Dirichlet 边界条件）：对于约束点，直接设置为目标位置

## 3. 实现细节

### 3.1 技术栈

- **编程语言**: C++17
- **数学库**: Eigen3（用于矩阵运算和稀疏矩阵求解）
- **构建系统**: CMake
- **输入格式**: OBJ 格式网格文件
- **约束格式**: CSV 文件（索引, 目标x, 目标y, 目标z）

### 3.2 核心数据结构

```cpp
class ARAP {
    vector<Vector3d> vertices_;        // 原始顶点
    vector<Vector3d> deformed_;         // 变形后顶点
    vector<vector<int>> neighbors_;     // 邻接关系
    vector<p_pair> constraints_;        // 约束点对
    vector<Matrix3d> rotations_;        // 局部旋转矩阵
    SparseMatrix<double> L_;           // 拉普拉斯矩阵
};
```

### 3.3 关键实现

#### 3.3.1 邻接关系构建

从面片信息构建顶点邻接关系，使用 `unordered_set` 去重：

```cpp
void ARAP::buildNeighbors(const Matrix3Xi& faces) {
    // 遍历所有面片，建立邻接关系
    for (int f = 0; f < faces.cols(); ++f) {
        int i = faces(0,f), j = faces(1,f), k = faces(2,f);
        temp_neighbors[i].insert(j); temp_neighbors[i].insert(k);
        // ...
    }
}
```

#### 3.3.2 拉普拉斯矩阵构建

使用均一权重构建拉普拉斯矩阵：

```cpp
void ARAP::buildLaplace() {
    // 对每个顶点 i，其邻接顶点 j 的权重为 -1
    // 对角线元素为邻接顶点数量
    for (int i = 0; i < n; ++i) {
        for (int j : neighbors_[i]) {
            triplets.push_back(T(i, j, -1.0));
        }
        triplets.push_back(T(i, i, wsum));
    }
}
```

#### 3.3.3 Local Step 实现

使用 SVD 分解计算最优旋转矩阵：

```cpp
void ARAP::LocalStep() {
    for (size_t i = 0; i < vertices_.size(); ++i) {
        Matrix3d S = Matrix3d::Zero();
        // 计算协方差矩阵
        for (int j : neighbors_[i]) {
            S += (pj - pi) * (qj - qi).transpose();
        }
        // SVD 分解
        JacobiSVD<Matrix3d> svd(S, ComputeFullU | ComputeFullV);
        Matrix3d R = svd.matrixV() * svd.matrixU().transpose();
        // 确保行列式为正
        if (R.determinant() < 0) {
            // 修正反射
        }
        rotations_[i] = R;
    }
}
```

#### 3.3.4 Global Step 实现

求解线性系统并应用约束：

```cpp
void ARAP::GlobalStep() {
    // 构建右端项 b
    for (int i = 0; i < n; ++i) {
        for (int j : neighbors_[i]) {
            Vector3d term = 0.5 * (rotations_[i] + rotations_[j]) * pij;
            bx(i) += term.x();
            // ...
        }
    }
    
    // 应用硬约束
    for (const auto& c : constraints_) {
        // 清空约束点的行，设置为单位行
        A.coeffRef(i, i) = 1.0;
        bx(i) = target.x();
        // ...
    }
    
    // 求解线性系统
    SparseLU<SparseMatrix<double>> solver;
    solver.compute(A);
    VectorXd new_x = solver.solve(bx);
    // ...
}
```

## 4. 实验设置

### 4.1 实验数据

- **输入网格**: `plane.obj`
  - 顶点数: 400
  - 面片数: 722
  - 网格类型: 平面网格（20×20 网格）

- **控制点约束**: `p.csv`
  - 约束点数量: 21 个
  - 约束类型: 边界点约束
  - 主要变形: 将部分边界点向上移动（z 坐标从 -0.052632 变为 0.1）

### 4.2 实验参数

- **迭代次数**: 10 次
- **权重方案**: 均一权重（uniform weights）
- **约束类型**: 硬约束（Dirichlet boundary conditions）

### 4.3 运行方式

```bash
# 编译
mkdir build && cd build
cmake ..
make

# 运行
./ARAP ../src/plane.obj ../src/p.csv ../src/result.obj
```

## 5. 实验结果

### 5.1 变形效果

通过设置 21 个控制点约束，实现了平面网格的局部变形：

1. **约束点分布**: 主要约束了网格底部边界的一条边（z = -0.57895），以及一个中间点
2. **变形特征**: 
   - 约束点按照指定位置移动
   - 周围区域平滑过渡，保持局部刚性
   - 变形区域自然，无明显扭曲

### 5.2 算法收敛性

ARAP 算法在 10 次迭代后达到收敛：
- 每次迭代都会更新局部旋转矩阵和全局顶点位置
- 能量函数逐步减小
- 变形结果稳定

### 5.3 性能分析

- **计算复杂度**: 
  - Local Step: $O(n \cdot d)$，其中 $n$ 是顶点数，$d$ 是平均度数
  - Global Step: $O(n)$ 的稀疏线性系统求解
- **内存占用**: 主要存储拉普拉斯矩阵（稀疏矩阵）和旋转矩阵

## 6. 问题与解决

### 6.1 索引问题

**问题**: 初始的 `p.csv` 文件中，控制点的索引不正确，导致无法正确匹配顶点。

**解决方案**: 
1. 编写 Python 脚本 `fix_indices.py` 自动匹配坐标
2. 通过坐标匹配找到正确的顶点索引（0-based）
3. 更新 CSV 文件格式为：`索引,目标x,目标y,目标z`

### 6.2 约束应用

**问题**: 需要正确应用硬约束，确保约束点精确移动到目标位置。

**解决方案**: 
- 在 Global Step 中，对约束点所在的行进行特殊处理
- 清空该行的所有非对角元素，设置对角元素为 1
- 将右端项设置为目标位置

## 7. 实验总结

### 7.1 主要成果

1. ✅ 成功实现了完整的 ARAP 变形算法
2. ✅ 验证了算法在平面网格上的变形效果
3. ✅ 实现了控制点约束的精确应用
4. ✅ 解决了索引匹配问题，建立了自动化工具

### 7.2 算法优点

- **局部保形**: 保持局部区域的形状特征
- **平滑变形**: 变形结果自然平滑
- **高效计算**: 迭代优化收敛快速
- **灵活约束**: 支持任意控制点约束

### 7.3 改进方向

1. **权重优化**: 可以使用 cotangent 权重替代均一权重，提高变形质量
2. **多分辨率**: 可以结合多分辨率方法处理大规模网格
3. **实时交互**: 优化算法性能，支持实时交互式变形
4. **约束类型**: 扩展支持软约束、方向约束等更多约束类型

## 8. 参考文献

1. Sorkine, O., & Alexa, M. (2007). As-rigid-as-possible surface modeling. *Eurographics Symposium on Geometry Processing*, 109-116.

2. Igarashi, T., Moscovich, T., & Hughes, J. F. (2005). As-rigid-as-possible shape manipulation. *ACM Transactions on Graphics*, 24(3), 1134-1141.

3. Liu, L., Zhang, L., Xu, Y., Gotsman, C., & Gortler, S. J. (2008). A local/global approach to mesh parameterization. *Computer Graphics Forum*, 27(5), 1495-1504.

---

**实验日期**: 2024年  
**实验者**: [姓名]  
**实验环境**: Linux, C++17, Eigen3

